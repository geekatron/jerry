# Security Test Cases — agents Bounded Context

<!-- Generated by: eng-security | Date: 2026-02-24 -->
<!-- Scope: src/agents/ manual code review -->
<!-- Reference: CWE Top 25 2025, OWASP ASVS 5.0 -->

## Document Sections

| Section | Purpose |
|---------|---------|
| [L0 Executive Summary](#l0-executive-summary) | Finding counts, top risks, immediate actions |
| [L1 Security Test Case List](#l1-security-test-case-list) | All test cases mapped to findings |
| [L2 Strategic Implications](#l2-strategic-implications) | Systemic patterns, architecture recommendations |

---

## L0 Executive Summary

**Overall security assessment:** MEDIUM-HIGH risk. Five vulnerability categories identified across the four files.
No single finding enables unauthenticated remote code execution in isolation, but two finding chains
(YAML anchor amplification + silent swallow, and constitutional bypass + tool escalation) represent
compound risks that could undermine the integrity of the agent build pipeline.

**Finding counts by severity:**

| Severity | Count |
|----------|-------|
| High | 2 |
| Medium | 5 |
| Low | 4 |
| Info | 2 |
| **Total** | **13** |

**Top 3 risk areas:**

1. **Path traversal in repository lookup and generation (High, CWE-22)** — `skill` and `agent_name`
   parameters accepted from YAML files and CLI arguments flow directly into `pathlib.Path` joins with
   no sanitization. An attacker-controlled `.agent.yaml` with `skill: ../../../etc` writes generated
   artifacts outside the skills tree.

2. **Constitutional bypass via substring matching (High, CWE-287 analog)** — `_ensure_constitutional_triplet`
   uses `any(code in p for p in principles)` substring matching. A principle string
   `"P-003-waived: Recursive Subagents Permitted"` satisfies the P-003 check while asserting the
   inverse intent. The function also fires only in the `extract()` path, leaving the `generate()` path
   without triplet enforcement.

3. **Tool escalation through declaration bypass (Medium, CWE-285)** — The worker agent Task-tool
   exclusion filter (`t != "agent_delegate"`) operates on abstract names only. A second abstract tool
   name mapped to vendor name "Task" in `mappings.yaml` bypasses the filter. Additionally, `forbidden_tools`
   is populated during `extract()` but never consulted by `_build_frontmatter()` to block emission.

**Recommended immediate actions:**

1. Canonicalize and validate all path components from YAML fields before joining with `pathlib.Path`.
2. Replace substring-match constitutional checks with exact-match against a defined allowlist of valid
   principle strings.
3. Add a post-generation assertion that no output `.md` file's tools list contains the word "Task" for
   agents whose `tool_tier` is not T5.

---

## L1 Security Test Case List

### Finding 1 — YAML Anchor/Alias Memory Amplification (CWE-400, Medium)

**Location:** `src/agents/infrastructure/persistence/filesystem_agent_repository.py:119`
and `src/agents/infrastructure/adapters/claude_code_adapter.py:129,394`

**Evidence:** `yaml.safe_load` is used at all three call sites. Python's PyYAML `safe_load` expands
YAML anchors and aliases into in-memory Python objects before returning. A crafted `.agent.yaml` or
`.governance.yaml` with exponentially nested aliases (billion-laughs pattern) will cause unbounded
memory expansion at load time. `safe_load` does NOT defend against this; it only defends against
arbitrary Python object instantiation.

**CVSS 3.1:** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H — 5.5 Medium (requires write access to
the skills directory to plant a crafted file).

```
FILE: tests/unit/agents/infrastructure/persistence/test_filesystem_agent_repository_security.py
- test_yaml_anchor_alias_expansion_raises_or_limits_memory
  # Craft a YAML string with 10-level nested anchor amplification.
  # Verify that _load_agent raises an exception or returns None
  # rather than expanding exponentially. Assert memory usage stays
  # below a reasonable bound (e.g., 50 MB for a trivially small file).

- test_yaml_aliases_in_agent_yaml_do_not_produce_unexpected_structure
  # Craft .agent.yaml using YAML anchors where &anchor declares a
  # tool name of "agent_delegate" and an alias reuses it in native_tools.
  # Verify the alias expansion does not bypass tool-name filtering and
  # that native_tools list is validated as strings only.

- test_yaml_merge_keys_do_not_escalate_tool_tier
  # Craft .agent.yaml using YAML merge key (<<) to merge a dict that
  # sets tool_tier: T5 into a base dict that declares tool_tier: T1.
  # Verify that the parsed CanonicalAgent reflects the explicit value
  # from the merge rather than an escalated value, and that merge key
  # expansion does not produce unexpected keys in the parsed dict.
```

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_governance_yaml_anchor_amplification_does_not_crash_extract
  # Provide a governance YAML with a billion-laughs anchor structure to
  # extract(). Verify it raises a known exception type or returns safely
  # and does not consume unbounded memory. Uses resource.setrlimit or
  # tracemalloc for memory assertion.

- test_governance_yaml_safe_load_rejects_python_object_tags
  # Provide a governance YAML with !!python/object/apply:os.system call.
  # Verify safe_load does NOT execute the tag (PyYAML safe_load guarantee).
  # Explicit regression test; documents the safe_load contract is present.
```

---

### Finding 2 — Silent YAML Error Swallow Causes Data Loss (CWE-755, Low)

**Location:** `src/agents/infrastructure/adapters/claude_code_adapter.py:393-397`

**Evidence:** `_parse_md` catches `yaml.YAMLError` and returns `{}` with no log, no exception
propagation, and no caller notification. A malformed frontmatter in a `.md` file (e.g., tabs in YAML,
unbalanced quotes) produces an empty frontmatter dict. The caller in `extract()` then populates
`CanonicalAgent.name` from `frontmatter.get("name", md_path.stem)`, so the agent silently acquires
the filename as its name. This masks corruption.

**CVSS 3.1:** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N — 3.3 Low

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_malformed_frontmatter_yaml_returns_empty_dict_not_raises
  # Provide MD content where frontmatter contains a tab character
  # (invalid YAML). Verify _parse_md returns ({}, body) tuple not an
  # exception. Documents the silent-swallow behavior is at least known.

- test_malformed_frontmatter_propagates_as_filename_stem_name
  # Full extract() call with malformed YAML frontmatter. Verify
  # CanonicalAgent.name equals the file stem (md_path.stem) not a
  # value from YAML. Asserts the degraded-path behavior is predictable.

- test_parse_md_with_valid_yaml_containing_injected_keys_is_filtered
  # Provide frontmatter with a non-official Claude Code field
  # (e.g., __proto__: ..., or constructor: ...) to check that
  # only recognized fields are consumed downstream.
```

---

### Finding 3 — Prompt Body XML Tag Breakout (CWE-116, Medium)

**Location:** `src/agents/domain/services/prompt_transformer.py:134-138`

**Evidence:** `_xml_to_markdown` uses the regex `<([a-z_]+)>\s*\n?(.*?)\n?\s*</\1>` with `re.DOTALL`.
The lazy quantifier `.*?` (rather than a true possessive/atomic group) can be exploited when prompt
content inside an XML tag itself contains a closing sequence. For example, if the content of an
`<identity>` block contains the literal string `</identity>` (e.g., in a code example or table),
the regex matches the FIRST `</identity>` and assigns truncated content to the section, leaving the
remainder of the original content unmatched and dropped from output.

Additionally, `_heading_to_tag` auto-derives XML tag names from unknown headings. A markdown heading
like `## </identity><new_section>` would pass through `re.sub(r"[^a-z0-9]+", "_", ...)` and produce
`_identity_new_section_` — the special characters are stripped — but a heading of `## agent` would
produce the tag name `agent`, which collides with the outer `<agent>` wrapper applied in `_build_body`.

**CVSS 3.1 (tag breakout / content truncation):** AV:L/AC:M/PR:L/UI:N/S:U/C:N/I:M/A:N — 4.2 Medium

```
FILE: tests/unit/agents/domain/services/test_prompt_transformer_security.py
- test_xml_content_containing_closing_tag_is_not_truncated
  # Create an XML body where <identity> block content contains the
  # literal string "</identity>" (e.g., in a markdown code block).
  # Call from_xml() and verify the full content is preserved and not
  # split at the inner </identity> occurrence. Regression for the
  # greedy-match truncation risk.

- test_xml_to_markdown_preserves_content_with_nested_xml_examples
  # Similar to above but with <identity>...<example_tag>...</example_tag>...</identity>.
  # Verify nested tag-like strings in content are treated as content not structure.

- test_heading_to_tag_with_agent_name_produces_collision
  # Call _heading_to_tag("agent") and verify it returns "agent".
  # Then call _markdown_to_xml() on a body with "## agent" section.
  # Verify the generated output contains <agent>...</agent> section,
  # and that _build_body wrapping adds a SECOND <agent> wrapper,
  # resulting in nested <agent> tags in the output. Documents collision.

- test_heading_to_tag_with_xml_special_chars_is_sanitized
  # Call _heading_to_tag with a heading containing "<", ">", "&", '"'.
  # Verify returned tag contains only [a-z0-9_] characters.
  # Verify no angle brackets reach the output XML.

- test_heading_with_closing_tag_in_name_does_not_break_output_xml
  # Markdown body with heading "## </identity>" (angle brackets present).
  # After _markdown_to_xml(), verify output XML parses as valid XML or
  # at minimum that no closing tags from the heading escape into structure.
```

---

### Finding 4 — Tool Name Substitution Via Substring Replace (CWE-116, Low)

**Location:** `src/agents/domain/services/tool_mapper.py:167-168`

**Evidence:** `substitute_tool_names_in_text` uses `str.replace(old, new)` with no word-boundary
enforcement. Replacements are sorted longest-first to reduce partial hits, but the logic does not
use regex word boundaries (`\b`). A prompt body containing the phrase "Read the file carefully"
would have "Read" replaced with "file_read" during reverse substitution if "Read" is the claude_code
vendor name for file_read. More critically, if a tool vendor name is a common English word (e.g.,
"Write", "Edit", "Bash", "Task"), arbitrary prose in the prompt body is silently mutated. An agent
that mentions the word "Task" in documentation prose would have that word replaced with "agent_delegate"
during reverse-map, or vice versa in forward map — producing corrupted prompt output.

**CVSS 3.1:** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N — 3.3 Low

```
FILE: tests/unit/agents/domain/services/test_tool_mapper_security.py
- test_substitute_tool_names_does_not_replace_substring_within_word
  # Prompt text: "Read carefully about ReadFile operations."
  # Forward substitution with claude_code target replaces "Read" -> "file_read".
  # Verify "ReadFile" is NOT mutated (it contains "Read" as a substring).
  # Documents the absent word-boundary protection as a known gap.

- test_substitute_does_not_corrupt_xml_tag_names_containing_tool_words
  # Prompt text with XML tag <bash_execute>...</bash_execute>.
  # Verify that forward substitution does NOT replace "bash" within the
  # tag name, and that the XML structure is preserved after substitution.

- test_substitute_reverse_map_task_word_in_prose
  # Prompt body: "Complete the Task by following instructions."
  # Reverse substitution from claude_code. Verify "Task" in prose is
  # replaced with "agent_delegate". Documents that prose mentioning
  # "Task" (capital T) is corrupted by reverse substitution — or verify
  # it is NOT corrupted if word-boundary protection exists.

- test_substitute_does_not_expand_empty_tool_name_to_replace_everywhere
  # If a tool maps to an empty string "" for a vendor, verify substitute
  # does not call str.replace("", ...) which replaces between every character.
  # tool_map entry: {"some_tool": {"claude_code": ""}}. Should skip or raise.
```

---

### Finding 5 — Path Traversal in Skill and Agent Name (CWE-22, High)

**Location:**
- `src/agents/infrastructure/persistence/filesystem_agent_repository.py:58, 86, 106`
- `src/agents/infrastructure/adapters/claude_code_adapter.py:79, 117`

**Evidence:**

`FilesystemAgentRepository.list_by_skill(skill)` joins `self._skills_dir / skill / "composition"` where
`skill` comes from directory iteration in `list_all()` (safe) but also from the external caller in
`ClaudeCodeAdapter.generate()` at line 79 where `agent.skill` is set from `.agent.yaml` data field.
An `.agent.yaml` with `skill: ../../../tmp` would cause `generate()` to write output artifacts to
`skills/../../../tmp/agents/`, which resolves to `/tmp/agents/`.

`FilesystemAgentRepository.get(agent_name)` joins `comp_dir / f"{agent_name}.agent.yaml"` where
`agent_name` is supplied externally. `agent_name = "../../secret"` produces a path that traverses
out of the composition directory.

`ClaudeCodeAdapter.extract(agent_md_path)` at line 117 accepts a raw string and calls `Path(agent_md_path)`,
then `md_path.read_text()`. No check that the resolved path is under an expected root. A caller passing
`/etc/passwd` reads that file.

**CVSS 3.1 (write-side via generate):** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L — 6.1 High
**CVSS 3.1 (read-side via extract):** AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N — 5.5 Medium

```
FILE: tests/unit/agents/infrastructure/persistence/test_filesystem_agent_repository_security.py
- test_path_traversal_in_agent_name_get_raises_or_returns_none
  # Call repo.get("../../../etc/passwd"). Verify the method does NOT
  # attempt to read /etc/passwd and either raises ValueError or returns None.
  # Uses a tmp_path fixture; assert no file outside tmp_path is accessed.

- test_path_traversal_in_skill_name_list_by_skill_raises_or_returns_empty
  # Call repo.list_by_skill("../../../etc"). Verify the method returns []
  # or raises ValueError and does NOT access paths outside skills_dir.
  # Use tmp_path; assert resolved comp_dir is under skills_dir.

- test_path_traversal_in_get_composition_dir_raises_or_returns_safe
  # Call repo.get_composition_dir("../../../etc"). Verify returned path
  # is still under skills_dir or method raises ValueError.

- test_agent_name_with_null_byte_is_rejected
  # Call repo.get("agent\x00.evil"). Verify it raises or returns None
  # and does not produce a filesystem access with null byte in path.

- test_skill_name_with_absolute_path_is_rejected
  # Call repo.list_by_skill("/etc"). Verify it raises or returns []
  # and does not traverse to an absolute path outside skills_dir.
```

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_path_traversal_in_agent_skill_during_generate
  # Provide a CanonicalAgent with skill="../../../tmp". Call generate().
  # Verify the returned GeneratedArtifact.path is under skills_dir or
  # that generate() raises ValueError before producing the artifact.

- test_path_traversal_in_agent_name_during_generate
  # Provide a CanonicalAgent with name="../../evil-agent". Call generate().
  # Verify the returned GeneratedArtifact.path is under skills_dir or raises.

- test_extract_with_path_outside_skills_dir_is_rejected
  # Call extract("/etc/passwd"). Verify it raises ValueError or FileNotFoundError
  # before reading file contents, asserting that absolute paths outside the
  # expected directory tree are rejected.

- test_extract_with_relative_path_traversal_is_rejected
  # Call extract("../../sensitive.md"). Verify rejection without file read.
```

---

### Finding 6 — Tool Escalation: Task Via Alternate Abstract Name (CWE-285, Medium)

**Location:** `src/agents/infrastructure/adapters/claude_code_adapter.py:252-253`

**Evidence:** The worker-agent Task exclusion in `_build_frontmatter` is:

```python
tools_to_map = [t for t in agent.native_tools if t != "agent_delegate"]
```

This checks abstract name equality. If `mappings.yaml` is modified (or an alternate ToolMapper instance
is constructed) to map a second abstract name — for example `task_execute` — to vendor name "Task",
then an agent declaring `native_tools: [task_execute]` passes the filter unimpeded and receives "Task"
in its generated frontmatter. The filter enforces only the single string "agent_delegate".

**CVSS 3.1:** AV:L/AC:M/PR:H/UI:N/S:U/C:N/I:H/A:N — 4.4 Medium
(requires write access to mappings.yaml or ToolMapper construction, which is privileged; but the
absence of vendor-name-level gating means the control is incomplete.)

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_task_tool_excluded_by_abstract_name_agent_delegate
  # Standard case: agent with native_tools=["agent_delegate"] at T1 tier.
  # Verify "Task" does NOT appear in generated frontmatter tools string.

- test_task_tool_escalation_via_alternate_abstract_name
  # Construct ToolMapper where "task_execute" maps to claude_code="Task".
  # Create ClaudeCodeAdapter with this mapper.
  # Create CanonicalAgent with tool_tier=T1, native_tools=["task_execute"].
  # Call generate(). Verify "Task" DOES appear in the output tools string,
  # documenting the gap. (This test documents the vulnerability, not correct
  # behavior; it is expected to FAIL if a fix is applied that checks vendor names.)

- test_build_frontmatter_never_emits_task_for_non_t5_agent_regardless_of_abstract_name
  # Same setup as above but asserts the DESIRED behavior: even when an
  # alternate abstract name maps to "Task", a T1/T2/T3/T4 agent's
  # generated frontmatter must not contain "Task". This test is the
  # acceptance criterion for the fix.

- test_forbidden_tools_field_is_consulted_during_generate
  # CanonicalAgent with forbidden_tools=["agent_delegate"] but
  # native_tools=["agent_delegate"] (contradictory). Verify that
  # _build_frontmatter excludes "Task" from output. Documents whether
  # forbidden_tools is actually enforced during generation (currently it is not).

- test_extract_t5_agent_does_not_add_agent_delegate_to_forbidden_tools
  # Provide an .md file with tool_tier=T5 in governance YAML.
  # Call extract(). Verify forbidden_tools is [] (not ["agent_delegate"]).
  # Verify the extracted CanonicalAgent has has_delegation=True.

- test_extract_non_t5_agent_adds_agent_delegate_to_forbidden_tools
  # Provide an .md with tool_tier=T1. Call extract().
  # Verify forbidden_tools == ["agent_delegate"].
```

---

### Finding 7 — Constitutional Bypass Via Substring Match (CWE-287 analog, High)

**Location:** `src/agents/infrastructure/adapters/claude_code_adapter.py:435-450`

**Evidence:** `_ensure_constitutional_triplet` uses:

```python
if not any(code in p for p in principles):
    principles.append(full_text)
```

`code in p` is Python `str.__contains__`, a substring check. Any string containing the substring
`"P-003"` — including `"P-003-waived"`, `"not-P-003"`, `"P-003 does not apply"` — passes the check.
The method considers the principle satisfied and does NOT append the required principle text.

Additionally, `_ensure_constitutional_triplet` is only called in the `extract()` path (line 176).
The `generate()` path calls `_build_governance_yaml()` which writes `agent.constitution` as-is
without verifying the triplet is present. An agent with `constitution: {}` passes through `generate()`
without complaint.

**CVSS 3.1 (principle spoofing):** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N — 5.5 Medium
**CVSS 3.1 (generate path missing enforcement):** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:M/A:N — 4.0 Medium
Combined rating for the finding: High (5.5, with systemic bypass implication).

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_constitutional_triplet_bypass_via_negating_prefix
  # constitution = {"principles_applied": ["P-003-waived: subagents allowed"]}
  # Call _ensure_constitutional_triplet(). Verify it does NOT append
  # "P-003: No Recursive Subagents (Hard)" — i.e., the method incorrectly
  # considers P-003 satisfied. Documents the substring-match vulnerability.

- test_constitutional_triplet_bypass_via_mid_string_code
  # constitution = {"principles_applied": ["ANTI-P-003 policy override"]}
  # Call _ensure_constitutional_triplet(). Verify P-003 check passes
  # (contains "P-003"), documenting that adversarial strings satisfy the check.

- test_constitutional_triplet_requires_exact_code_match_not_substring
  # Desired behavior test (acceptance criterion for the fix).
  # A principle string that CONTAINS "P-003" but is not a valid principle
  # statement should NOT satisfy the check. Verify required principle is
  # appended when the string is "not-P-003-compliant".

- test_constitutional_triplet_empty_principles_list_adds_all_three
  # constitution = {"principles_applied": []}
  # Verify all three (P-003, P-020, P-022) are appended. Baseline positive case.

- test_constitutional_triplet_missing_one_principle_adds_only_missing
  # constitution has P-003 and P-020 but not P-022.
  # Verify only P-022 is appended; P-003 and P-020 entry counts unchanged.

- test_constitutional_triplet_forbidden_actions_bypass_via_substring
  # constitution = {"forbidden_actions": ["P-003 is permitted here"]}
  # Verify _ensure_constitutional_triplet() does NOT append the required
  # "Spawn recursive subagents (P-003)" action, documenting the gap.

- test_generate_path_does_not_enforce_constitutional_triplet
  # CanonicalAgent with empty constitution={}. Call generate().
  # Read the generated .governance.yaml content. Verify it does NOT
  # contain principles_applied with all three codes — documenting that
  # generate() silently omits triplet enforcement (gap, not fix).

- test_generate_path_with_empty_constitution_should_enforce_triplet
  # Desired behavior: CanonicalAgent with empty constitution={} passed to
  # generate() should produce a governance YAML that includes at minimum
  # the constitutional triplet. Acceptance criterion for a fix.
```

---

### Finding 8 — _strip_agent_wrapper Mid-Content Truncation (CWE-116, Low)

**Location:** `src/agents/infrastructure/adapters/claude_code_adapter.py:454-480`

**Evidence:** `_strip_agent_wrapper` strips the last `</agent>` from the body using:

```python
if stripped.rstrip().endswith("</agent>"):
    stripped = stripped.rstrip()
    stripped = stripped[: -len("</agent>")].rstrip("\n")
```

If the body content legitimately contains `</agent>` mid-document (e.g., in a code block showing an
agent tag example, or in documentation prose), the last such occurrence is stripped even though it is
not the structural wrapper. Content after that point is silently discarded.

The corrupted-variant handler (`agent>` without `<`) at line 472 also strips ANY body beginning with
the string "agent>" — a body whose first non-whitespace content is a heading like `agent> some text`
in the corrupted format would be unintentionally stripped.

**CVSS 3.1:** AV:L/AC:M/PR:L/UI:N/S:U/C:N/I:L/A:N — 3.1 Low

```
FILE: tests/unit/agents/infrastructure/adapters/test_claude_code_adapter_security.py
- test_strip_agent_wrapper_preserves_mid_content_closing_tag
  # Body: "<agent>\n\nSome content with </agent> in a code block.\n\n</agent>"
  # Verify _strip_agent_wrapper preserves the inner </agent> in the code block
  # and only removes the outermost structural tags.

- test_strip_agent_wrapper_corrupted_variant_does_not_strip_legitimate_content
  # Body: "agent> is a special syntax used in..." (starts with "agent>" coincidentally).
  # Verify _strip_agent_wrapper does NOT treat this as a corrupted wrapper
  # and strip the opening "agent>" from legitimate content.

- test_strip_agent_wrapper_multiple_closing_tags_removes_only_last
  # Body with multiple </agent> tags; only the structural final tag should be removed.
  # Verify the inner </agent> occurrences are preserved.
```

---

### Finding 9 — Unvalidated `extra_yaml` Field Accepted and Stored (CWE-20, Info)

**Location:** `src/agents/infrastructure/persistence/filesystem_agent_repository.py:194`

**Evidence:** `_parse_agent` extracts all YAML keys not in `known_keys` into `extra_yaml` and
passes them directly to `CanonicalAgent`. While `extra_yaml` is not used in security-relevant logic
within these four files, it represents an unvalidated pass-through channel. Future code that reads
from `extra_yaml` without validation inherits this risk. No size limit or key count validation exists.

**CVSS 3.1:** N/A (informational; no current exploitable path identified)

```
FILE: tests/unit/agents/infrastructure/persistence/test_filesystem_agent_repository_security.py
- test_extra_yaml_does_not_accept_known_security_keys
  # Agent YAML with extra key "constitution" misspelled as "constitutoin" and
  # "tool_tier" as "toolTier". Verify these end up in extra_yaml, not in the
  # named fields — documenting that typo-attacks on known fields go to extra_yaml
  # and not the intended security-relevant field.

- test_extra_yaml_keys_with_path_traversal_values_are_not_interpreted
  # Agent YAML with extra key "custom_path: ../../etc/passwd".
  # Verify extra_yaml["custom_path"] stores the string value unchanged
  # and that no filesystem access occurs during _parse_agent.
```

---

### Finding 10 — BodyFormat.from_string Raises ValueError on Unknown Input (Info)

**Location:** `src/agents/domain/value_objects/body_format.py:47`

**Evidence:** `BodyFormat.from_string` raises `ValueError` for unrecognized format strings. In
`_parse_agent`, `body_format = BodyFormat.from_string(body_format_str)` is called with a value
from the YAML `portability.body_format` field. If this field contains an unexpected value, the
entire `_load_agent` call is caught by the broad `except Exception: return None` at line 136 of
`filesystem_agent_repository.py`. The exception is silently swallowed, the agent is not loaded,
and there is no indication to the operator. This is an availability concern for malformed input.

**CVSS 3.1:** AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L — 3.3 Low

```
FILE: tests/unit/agents/infrastructure/persistence/test_filesystem_agent_repository_security.py
- test_invalid_body_format_in_yaml_causes_load_agent_to_return_none
  # Craft .agent.yaml with portability.body_format = "unknown_format".
  # Verify _load_agent returns None (not raises) due to except Exception swallow.
  # Verify no agent is added to the list_all() results.

- test_invalid_tool_tier_in_yaml_causes_load_agent_to_return_none
  # Craft .agent.yaml with tool_tier: "T9". Verify _load_agent returns None.
  # Verify the broad exception swallow logs or surfaces enough for debugging.
```

---

## L2 Strategic Implications

### Systemic Pattern 1: Trust Boundary at YAML Intake Is Absent

All four files treat filesystem-sourced YAML as trusted. There is no input validation layer between
raw YAML content and domain object construction. The `_parse_agent` broad `except Exception: return None`
functions as a de-facto silencer of all parsing errors. This means malformed or adversarial input
produces no observable error — it simply results in agents not being built, with no operator notification.

**Architectural recommendation:** Introduce a dedicated `CanonicalAgentValidator` at the application
layer that runs schema validation (JSON Schema against `agent-canonical-v1.schema.json`) before
`CanonicalAgent` construction. This validator should raise a typed exception (`ValidationError`) not
swallow it.

### Systemic Pattern 2: Security Controls Operate on Abstract Names, Not Invariants

The tool escalation filter (`t != "agent_delegate"`) and the constitutional check (`code in p`) both
operate on mutable string values rather than stable semantic invariants. Strings can be crafted to
satisfy checks while violating intent. This is a systemic design gap: security-relevant classification
(is this agent a worker? does it comply with P-003?) should be enforced via typed enums or verified
against a closed allowlist, not substring matching.

**Architectural recommendation:** Replace all security-relevant string checks with typed value-object
comparisons. The constitutional triplet enforcement should match against an exact allowlist of canonical
principle strings stored as module-level constants, not `code in p` on arbitrary strings.

### Systemic Pattern 3: Path Construction Has No Root-Confinement Discipline

`pathlib.Path` joins do not enforce that the result stays under the intended root directory. The
standard Python pattern for root-confinement is `resolved_path.resolve().is_relative_to(root.resolve())`.
None of the four files apply this pattern. All path-construction sites in `FilesystemAgentRepository`
and `ClaudeCodeAdapter.generate()` are vulnerable to the same class of path traversal.

**Architectural recommendation:** Create a single `safe_join(root: Path, *parts: str) -> Path` utility
in the shared kernel that resolves the joined path and asserts it is under `root`. All repository and
adapter path construction should use this utility exclusively.

### Threat Model Correlation

The path traversal findings (Finding 5) and tool escalation findings (Finding 6) correspond to the
STRIDE category **Elevation of Privilege**. The constitutional bypass (Finding 7) corresponds to
**Tampering** with security metadata. The YAML amplification (Finding 1) corresponds to **Denial of
Service**. These are consistent with what an eng-architect threat model of a build pipeline accepting
developer-controlled YAML files would predict as the primary risk surface.

### ASVS 5.0 Chapter Verification Status

| Chapter | Requirement | Status |
|---------|-------------|--------|
| V5.1 Input Validation | 5.1.1 — All user-controllable data validated | FAIL — YAML fields not validated before use |
| V5.1 Input Validation | 5.1.3 — Structured data validated against schema | FAIL — schema validation not called in build path |
| V5.2 Sanitization and Sandboxing | 5.2.1 — All untrusted HTML/XML output encoded | PARTIAL — XML tags auto-derived but not entity-encoded |
| V8.1 General Data Protection | 8.1.1 — Sensitive data not stored unnecessarily | PASS — no credentials handled |
| V4.1 General Access Control | 4.1.1 — Access controls enforced at trust boundary | FAIL — no confinement check on path joins |
| V4.2 Operation Level Access Control | 4.2.1 — Sensitive operations protected | FAIL — tool escalation filter incomplete |

---

*Generated by: eng-security*
*Review method: Manual data-flow tracing, CWE Top 25 2025 checklist*
*SSDF alignment: PW.7 (Review human-readable code to identify vulnerabilities)*
*Date: 2026-02-24*
